package com.seanbot.gameoflife;

import java.util.Random;

/**
 * 
 * @author Sean Clapp
 * @email seanclapp@gmail.com
 * 
 *        This will be used to store the shapes that will be called For example,
 *        if you want to build a glider, you will call the buildGlider() method.
 * 
 */
public class ShapeManager {

	private Random r = new Random();

	public ShapeManager() {
		// TODO Auto-generated constructor stub
	}

	/**
	 * (This isn't implemented fully yet)
	 * 
	 * Sets cells to be alive or dead based off a pre-built 2d array
	 * (shapeArray). This can be used to build any shape necessary if you have
	 * the appropriate 2d array.
	 * 
	 * @param shapeArray
	 *            the 2d array that will specify the object to be built. A "1"
	 *            represents a live cell and a "0" represents a dead cell
	 * @param touched_x
	 *            the touched x coordinate to be used in determining the shape's
	 *            position on the board
	 * @param touched_y
	 *            the touched y coordinate to be used in determining the shape's
	 *            position on the board
	 * @param startingTouchColor
	 *            desired starting color of the shape. Each cell will be *close*
	 *            to this color.
	 * 
	 */
	public void buildShape(int[][] shapeArray, float touched_x,
			float touched_y, int startingTouchColor, int screenW, int screenH) {
		int rows = shapeArray.length;
		int cols = shapeArray[0].length;
		int bounds = 100;

		/**
		 * Starts the cell at the top left position of the array. (The touched
		 * is still the center)
		 */
		Cell cc = CellList.getInstanceOf().getCellByPos(
				touched_x - 10 * (rows / 2), touched_y - 10 * (cols / 2));
		float origCellXpos = cc.getxPos();
		float origCellYPos = cc.getyPos();
		float cellXpos = cc.getxPos();
		float cellYpos = cc.getyPos();

		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; i++) {
				/**
				 * Check to make sure the cell is in bounds.
				 */
				if (cellXpos > 0 && cellYpos > 0 && cellXpos < bounds
						&& cellYpos < bounds) {
					if (shapeArray[i][j] == 1) {
						cc.setIsAlive(1);
					}
				}
				cc = CellList.getInstanceOf().getCellByPos(cellXpos + 10,
						cellYpos);
			}
			cellXpos = origCellXpos;
			cellYpos += 10;
		}
	}

	/**
	 * This will build a glider shape. This will be deprecated once buildShape
	 * is finished.
	 * 
	 * @param touched_x
	 *            the touched x coordinate
	 * @param touched_y
	 *            the touched y coordinate
	 * @param startingTouchColor
	 *            desired starting color of the shape. Each cell will be *close*
	 *            to this color.
	 */

	public void buildGlider(float touched_x, float touched_y,
			int startingTouchColor) {

		Cell cc;

		if (touched_y > 10) {
			cc = CellList.getInstanceOf().getCellByPos(touched_x + 10,
					touched_y - 10);
			cc.setIsAlive(1);
			cc.setCellColor(startingTouchColor + r.nextInt(150));
		}

		if (touched_x > 10) {
			cc = CellList.getInstanceOf().getCellByPos(touched_x - 10,
					touched_y);
			cc.setIsAlive(1);
			cc.setCellColor(startingTouchColor + r.nextInt(150));
		}

		if (touched_x < CellList.getInstanceOf().getWidth() - 10
				&& touched_y < CellList.getInstanceOf().getHeight() - 10) {
			cc = CellList.getInstanceOf().getCellByPos(touched_x + 10,
					touched_y + 10);
			cc.setIsAlive(1);
			cc.setCellColor(startingTouchColor + r.nextInt(150));
		}

		if (touched_y < CellList.getInstanceOf().getHeight() - 10) {
			cc = CellList.getInstanceOf().getCellByPos(touched_x,
					touched_y + 10);
			cc.setIsAlive(1);
			cc.setCellColor(startingTouchColor + r.nextInt(150));
		}

		if (touched_x < CellList.getInstanceOf().getWidth() - 10) {
			cc = CellList.getInstanceOf().getCellByPos(touched_x + 10,
					touched_y);
			cc.setIsAlive(1);
			cc.setCellColor(startingTouchColor + r.nextInt(150));
		}
	}
}
